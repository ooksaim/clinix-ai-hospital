import { NextRequest, NextResponse } from 'next/server'

interface ReportRequest {
  transcript: string
  patientInfo: {
    patientName: string
    patientId: string
    dateOfBirth: string
    studyType: string
    referringPhysician: string
  }
}

export async function POST(request: Request) {
  // Validate OpenAI API key early
  if (!process.env.OPENAI_API_KEY) {
    return NextResponse.json(
      { error: 'OpenAI API key not configured' },
      { status: 500 }
    )
  }

  try {
    const { transcript, patientInfo }: ReportRequest = await request.json()
    
    if (!transcript || transcript.trim().length === 0) {
      return NextResponse.json({ error: 'No transcript provided' }, { status: 400 })
    }

    // Create a comprehensive system prompt for medical report generation
    const systemPrompt = `You are an expert radiologist AI assistant specialized in generating professional radiology reports. Your task is to analyze voice transcriptions of radiology findings and format them into standardized, professional medical reports.

INSTRUCTIONS:
1. Analyze the provided transcript for medical findings, observations, and clinical details
2. Structure the information into proper radiology report format
3. Use appropriate medical terminology and professional language
4. Ensure accuracy and completeness
5. Follow standard radiology report structure

REPORT STRUCTURE:
- Examination: Brief description of the study performed
- Findings: Detailed objective observations from imaging
- Impression: Clinical interpretation and diagnosis
- Recommendations: Follow-up care or additional studies needed

GUIDELINES:
- Be precise and objective in descriptions
- Use proper anatomical terminology
- Maintain professional medical language
- Include relevant negative findings
- Provide clear, actionable recommendations
- Ensure consistency with the study type: ${patientInfo.studyType}

Please generate a professional radiology report based on the transcript provided.`

    const userPrompt = `Patient Information:
- Name: ${patientInfo.patientName}
- Patient ID: ${patientInfo.patientId}
- Date of Birth: ${patientInfo.dateOfBirth}
- Study Type: ${patientInfo.studyType}
- Referring Physician: ${patientInfo.referringPhysician}
- Study Date: ${new Date().toISOString().split('T')[0]}

Voice Transcript:
"${transcript}"

Please generate a complete radiology report with the following sections:
1. Examination
2. Findings  
3. Impression
4. Recommendations

Format the response as JSON with these exact fields:
{
  "examination": "string",
  "findings": "string", 
  "impression": "string",
  "recommendations": "string"
}`

    // Call OpenAI GPT-4 API for report generation
    const gptResponse = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // Using gpt-4o-mini for medical tasks
        messages: [
          {
            role: 'system',
            content: systemPrompt
          },
          {
            role: 'user', 
            content: userPrompt
          }
        ],
        temperature: 0.3, // Lower temperature for more consistent medical reports
        max_tokens: 1500,
        top_p: 0.9
      }),
    })

    if (!gptResponse.ok) {
      const error = await gptResponse.text()
      console.error('GPT API Error:', error)
      return NextResponse.json(
        { error: 'Failed to generate report' }, 
        { status: gptResponse.status }
      )
    }

    const gptResult = await gptResponse.json()
    const generatedContent = gptResult.choices[0]?.message?.content

    if (!generatedContent) {
      return NextResponse.json(
        { error: 'No content generated by AI' }, 
        { status: 500 }
      )
    }

    // Try to parse JSON response from GPT
    let reportSections
    try {
      // Extract JSON from the response (in case GPT adds extra text)
      const jsonMatch = generatedContent.match(/\{[\s\S]*\}/)
      if (jsonMatch) {
        reportSections = JSON.parse(jsonMatch[0])
      } else {
        throw new Error('No JSON found in response')
      }
    } catch (parseError) {
      // Fallback: Parse the response manually if JSON parsing fails
      console.warn('JSON parsing failed, using manual parsing:', parseError)
      
      reportSections = {
        examination: extractSection(generatedContent, 'examination') || `${patientInfo.studyType} examination was performed according to standard protocol.`,
        findings: extractSection(generatedContent, 'findings') || 'Unable to parse findings from transcript.',
        impression: extractSection(generatedContent, 'impression') || 'Clinical correlation recommended.',
        recommendations: extractSection(generatedContent, 'recommendations') || 'Follow-up as clinically indicated.'
      }
    }

    // Create complete report object
    const completeReport = {
      id: `RPT-${Date.now()}`,
      patientName: patientInfo.patientName,
      patientId: patientInfo.patientId,
      dateOfBirth: patientInfo.dateOfBirth,
      studyDate: new Date().toISOString().split('T')[0],
      studyType: patientInfo.studyType,
      referringPhysician: patientInfo.referringPhysician,
      examination: reportSections.examination,
      findings: reportSections.findings,
      impression: reportSections.impression,
      recommendations: reportSections.recommendations,
      radiologist: "Dr. AI Assistant (Reviewed)",
      reportDate: new Date().toISOString().split('T')[0],
      rawTranscript: transcript
    }
    
    return NextResponse.json({
      report: completeReport
    })

  } catch (error) {
    console.error('Report generation error:', error)
    return NextResponse.json(
      { error: 'Internal server error during report generation' }, 
      { status: 500 }
    )
  }
}

// Helper function to extract sections from text response
function extractSection(text: string, sectionName: string): string | null {
  const patterns = [
    new RegExp(`${sectionName}:?\\s*([^\\n]+(?:\\n(?!\\w+:)[^\\n]+)*)`, 'i'),
    new RegExp(`${sectionName}.*?:(.*?)(?=\\w+:|$)`, 'is'),
  ]
  
  for (const pattern of patterns) {
    const match = text.match(pattern)
    if (match && match[1]) {
      return match[1].trim()
    }
  }
  
  return null
}
